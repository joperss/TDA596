# Used when a new message is recieved via a POST request; will insert it at the end of te local board with the appripriate logical clock value and writeToQuorum it to the other vessels
def addMessageToInputTable(ip, msg):
  # We do this lock to ensure the order of the inputs
  # and to protect the remote lock-function
  mycontext['inputTableLock'].acquire()

  # Remotly lock nodes in write quorum.
  for ip in mycontext['W']:
    mycontext['remoteLock'].acquire()
    sendMessage(ip, mycontext['port'], 'LOCK')
  #####################################
  # Update (This is not realy needed in our version due to static write quorum, if non w-quorum write, I need to do a get afterwards)
  readQuorum()
  # I may release the inputTableLock because all the nodes are remotly locked
  # meaning that if another thread would try to write
  mycontext['inputTableLock'].release()
#  readQuorum()

  print 'Write to quorum'
  writeToQuorum(msg)

# Locks local host and replies that it has been locked.
def lockLocalHost(ip):
  mycontext['lockLocalHost'].acquire()
  sendMessage(ip, mycontext['port'], 'REMOTE')

# Updating local board after recieving a UPT-message.
# This function needs to be protected and may only be runned sequentaly.
# (This is handled elsewhere)
def upDateLocalBoard(msgheader):
  mycontext['boardList'].append(msgheader)

# Sends a HHTP OK when receiving a webbrowser request
def sendHTTPOK(sockobj):
  # The HTML code is divided in two parts, htmlpartone and hmtlparttwo.
  # mycontext['htmlinputtable'] is then inserted between them

  htmlpartone = """<html><head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Blackboard GroupName</title>
    </head>
    <body>
    <h2> Board Content</h2>"""

  htmlparttwo = """
    <br>
    <h3>Submit to board<h3>
    <textarea rows="4" cols="50" name="comment" form="usrform"></textarea>
    <form action="" id="usrform" method="post">
    <input type="submit">
    </form>
    </body></html>"""

  board = ""
  for content in mycontext['boardList']:
    board += "<p>" + content + "</p>" 


  htmlresponse = htmlpartone + board + htmlparttwo
  sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
  "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))


def receiveMessage(sockobj):
  msgheader = ""
  timeout = 2
  nextpart = ""
  first = 1

  while first or len(nextpart) == 1024:
    try:
      nextpart = sockobj.recv(1024)
      msgheader = msgheader + nextpart
      if first:
        first = 0
    except Exception, e:
      print 'Exception caught: ', str(e), ', in receiveMessage(). Will return ' + msgheader
      nextpart = ""
  return msgheader


def sendMessage(ip, port, msg, numberOfTries=1000, tryNumber=0):
  try:
    mycontext['socketLock'].acquire()
    s = openconn(ip, port)
    s.send(msg)
    s.close()
    mycontext['socketLock'].release()
  except Exception, e:
    print 'Exception caught: ', str(e)
    if(tryNumber < numberOfTries):

      mycontext['socketLock'].release()
      sendMessage(ip, port, msg, numberOfTries, tryNumber+1)
    else:
      raise e

# Updates the local board by doing a read from the read quorum.
# Upon exit this function has updated the local version.
def readQuorum():
  # This is for performance and ME-protection for the inputtable
#  if mycontext['readLock'].acquire(0):
  msg = 'CHECK'
  for vessel in mycontext['R']:
    sendMessage(vessel, mycontext['port'], msg)
  # Lock and wait for the messages to arrive
  mycontext['waitForAnswers'].acquire() # Used for synch. between threads

  # Logic for chosing the newest version
  maxSeqNumber = len(mycontext['boardList'])
  ip = getmyip()

  for tup in mycontext['readSeqAnswers']:
    tempSeqNumber = int(tup[0])
    tempIP = tup[1]
    if tempSeqNumber > maxSeqNumber:
      maxSeqNumber = tempSeqNumber
      ip = tempIP
  ########################################

  if ip != getmyip(): # If I don't have the latest version, get it!
    # Send a request: I wan't to copy your board
    sendMessage(ip, mycontext['port'], 'COPY:' + str(len(mycontext['boardList'])))
    # Wait for him to paste his board into mine.
    mycontext['copying'].acquire() # Used for synch. between threads

  mycontext['readSeqAnswers'] = []

def copyBoard(ip, msgheader):
  seqNumber = int(msgheader.split(':')[-1])
  for content in mycontext['boardList'][seqNumber:]:
    msg = "PASTE:" + content + ':MORE'
    sendMessage(ip, mycontext['port'], msg)
  msg = 'PASTE: :FINISHED'
  sendMessage(ip, mycontext['port'], msg)

def sendSeqNr(ip):
  msg = 'SEQ:' + str(len(mycontext['boardList'])) + ':' + getmyip()
  sendMessage(ip, mycontext['port'], msg)

def receiveSeqNumberLogic(msgheader):
  seqNumber = msgheader.split(':')[1]
  ip = msgheader.split(':')[2]
  mycontext['readSeqAnswers'].append((seqNumber,ip))

  if len(mycontext['readSeqAnswers']) == len(mycontext['R']):
    mycontext['waitForAnswers'].release()

def writeToQuorum(newInput):
  for ipn in mycontext['W']:
    msg ="UPT:" + newInput
    sendMessage(ipn, mycontext['port'], msg)

# Handles incoming communication
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  msgheader = receiveMessage(sockobj)

  if mycontext['state'] == 'RUNNING': 
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith ('GET' ):
      # If i'm currently being writed to, I will send my current version
      # that is at most 1 version behind (because I know that it is currently being updated)
      if mycontext['lockLocalHost'].acquire(0):
        readQuorum()
        mycontext['lockLocalHost'].release()
      sendHTTPOK(sockobj)
    elif msgheader.startswith( 'POST' ):
      addMessageToInputTable(getmyip(), msgheader.split('comment=')[-1])
      sendHTTPOK(sockobj)

  	
    # UPT-messages handles the updating of mycontext['boardList']
    elif msgheader.startswith( 'UPT' ):
      upDateLocalBoard(msgheader[4:])
      mycontext['lockLocalHost'].release()

    elif msgheader.startswith( 'CHECK' ):
      sendSeqNr(ip)
    elif msgheader.startswith( 'SEQ' ):
      receiveSeqNumberLogic(msgheader)
    elif msgheader.startswith( 'REMOTE' ):
      mycontext['remoteLock'].release()
    elif msgheader.startswith( 'LOCK' ):
      lockLocalHost(ip)
    elif msgheader.startswith( 'COPY' ):
      copyBoard(ip, msgheader)
    elif msgheader.startswith( 'PASTE' ):
      print ' PASTE'
      if msgheader.endswith( 'MORE' ):
        print ' MORE'
        upDateLocalBoard(msgheader.split(':')[1])
      else:
        print 'FINISHED'
        mycontext['copying'].release()


    stopcomm(thiscommhandle)

	
if callfunc == 'initialize':
  mycontext['state'] = 'RUNNING' # Not really used, but left if one would want to add feature, like fore example leader election
  mycontext['vessels'] = [] # List of all vessels (not scalable solution)
  mycontext['htmlinputtable'] = "" # The blackboard
  mycontext['socketLock'] = getlock()
  mycontext['inputTableLock'] = getlock() # Protects the input table
  mycontext['waitForAnswers'] =getlock()
  mycontext['waitForAnswers'].acquire()
  mycontext['remoteLock'] = getlock()
  mycontext['lockLocalHost'] = getlock()
  mycontext['copying'] = getlock()
  mycontext['copying'].acquire()

  mycontext['R'] = []
  mycontext['W'] = []
  mycontext['readSeqAnswers'] = []


  mycontext['boardList'] = []


  if len(callargs) > 2:
    raise Exception("Too many call arguments")

  # Running remotely (assuming that we pass input argument only remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  elif len(callargs) == 2:
    port = int(callargs[0])
    mycontext['port'] = port

    ip = getmyip()
    ipfile = open(callargs[1],'r')

    otherVessels = []
    for line in ipfile:
      if(line != ip):
        otherVessels.append(line.split()[0])
      mycontext['vessels'].append(line.split()[0])

    n = len(mycontext['vessels'])

    # The read quorum also always has the local host. This is handled in the read-methods
    mycontext['R'] = otherVessels[:(n/2-1+n%2)] # This is the read quorum, but the local vessel is missing. Because we don't want to send messages to it.
    mycontext['W'] = mycontext['vessels'][:(n/2+1+n%2)]

  # Running locally:
  # whenever we get a connection on 127.0.0.1:12345 we'll call board
  else:
    port = 12345
    ip = '127.0.0.1'
  
  listencommhandle = waitforconn(ip,port,board)
