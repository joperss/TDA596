def addMessageToInputTable(msg):
  mycontext['inputTableLock'].acquire()
  mycontext['htmlinputtable'] = mycontext['htmlinputtable'] + "<p>" + msg + "</p>"
  leaderBroadcast("<p>" + msg + "</p>")
  mycontext['inputTableLock'].release()

def upDateLocalBoard(msgheader):
  version = int(msgheader[3:].split(":")[-1]) ## MOST FIX, MUTAL ECXLUCION
  msg = msgheader[3:].split(":")[0]
  mycontext['upDateLocalBoardLock'].acquire()
  if (int(mycontext['maxVersion']) < int(version)):
      mycontext['maxVersion'] = version

  comp = (int(mycontext['version'])  + 1)
  if(int(comp) == int(version)):
#        print msgheader
    print "Updating table"
#       print ("\n\n\nAdding to board: " + msg)
    mycontext['htmlinputtable'] += msg
    mycontext['version'] = version

    i = version
    while (i<mycontext['maxVersion']):
      i+=1
      result = mycontext['savedMessages'][i]
      if result == null:
        return
      else:
        mycontext['htmlinputtable'] += result
        mycontext['version'] = i

#    print ("UPDATED BOARD")
  elif (int(mycontext['version']) + 1 < version):
    print "woo!"
    mycontext['savedMessages'][version] = msg
    

  mycontext['upDateLocalBoardLock'].release()

def sendHTTPOK(sockobj):
  # The HTML code is divided in two parts, htmlpartone and hmtlparttwo.
  # mycontext['htmlinputtable'] is then inserted between them

  htmlpartone = """<html><head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Blackboard GroupName</title>
    </head>
    <body>
    <h2> Board Content</h2>"""

  htmlparttwo = """
    <br>
    <h3>Submit to board<h3>
    <textarea rows="4" cols="50" name="comment" form="usrform"></textarea>
    <form action="" id="usrform" method="post">
    <input type="submit">
    </form>
    </body></html>"""

  htmlresponse = htmlpartone + mycontext['htmlinputtable'] + htmlparttwo
  sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
  "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))


def receiveMessage(sockobj):
#  print("Start recieving")
  msgheader = ''
  timeout = 2
  nextpart = "placeholder"
  first = 1
  i = 1

  while first or len(nextpart) == 1024:
    if first:
      first = 0

    try:
      nextpart = sockobj.recv(1024)
      i += 1
      msgheader = msgheader + nextpart
    except Exception, e:
      print 'Exception caught: ', str(e), ', in receiveMessage(). Will try again'
      nextpart = ""
  return msgheader


def sendMessage(ip, port, msg, numberOfTries=1000, tryNumber=0):
  try:
    mycontext['socketLock'].acquire()
    s = openconn(ip, port)
    s.send(msg)
    print "Message sent"
    s.close()
    mycontext['socketLock'].release()
  except Exception, e:
    print 'Exception caught: ', str(e)
    print "Neighbour not ready, will try again"
    if(tryNumber < numberOfTries):
      print "Socket wasn't ready, will try again"

      mycontext['socketLock'].release()
      sendMessage(ip, port, msg, numberOfTries, tryNumber+1)
    else:
      raise e
def leaderBroadcast(newInput):
  mycontext['version'] = str(int(mycontext['version']) + 1)
  for ipn in mycontext['vessels']:
    if(ipn != mycontext['leader']):
      msg ="UPT" + newInput + ":" + mycontext['version']
      sendMessage(ipn, mycontext['port'], msg)

# Sets leader to '' and sends the vessel's first message in the leader election
def startLeaderElection():
  mycontext['leader'] = ''
  print "Opening connection to ip " + mycontext['nextvessel'] + " on port " + str(mycontext['port'])
  
  msg = "ELECT:" + getmyip() + ":" + str(mycontext['electnum'])
  sendMessage(mycontext['nextvessel'], mycontext['port'], msg) 

def handleELECTmessage(msgheader):
    if msgheader.split(':')[1] == getmyip():
      msgheader = msgheader[6:]
      vesselList = msgheader.split(':')
      index = 0
      max = 0
      leaderIndex = 0
      print vesselList
      for n in vesselList:
        if index % 2 != 0:
          # BOGUS: bad if n == max
          if n > max:
            max = n
            leaderIndex = index-1
        index += 1

      mycontext['leader'] =  vesselList[leaderIndex]
      mycontext['htmlinputtable'] = "<p>" + mycontext['leader'] + " has value " + str(max) + "</p>"
      # Send CONF
      print "Sending conf message, starts running phase"
      msg = "CONFIRM:" + mycontext['leader']
      sendMessage(mycontext['nextvessel'], mycontext['port'], msg)
      mycontext['state'] = 'RUNNING'
    else:
   # Add values to message
      msg = msgheader + ":" + getmyip() + ":" +  str(mycontext['electnum'])
      sendMessage(mycontext['nextvessel'], mycontext['port'], msg)     

def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  print "Bord request"
  msgheader = receiveMessage(sockobj)

  if mycontext['state'] == 'ELECTION':
    print ("Message will be hanled by election principles")
 #   msgheader = receiveMessage(sockobj) 
    if msgheader.startswith('ELECT'):
      handleELECTmessage(msgheader)

    elif msgheader.startswith('CONFIRM'):
      mycontext['leader'] = msgheader.split(':')[-1]
      mycontext['htmlinputtable'] = "<p>" + mycontext['leader'] + "</p>"


      msg = msgheader
      sendMessage(mycontext['nextvessel'], mycontext['port'], msg)
      print("Sent CONF message to neigbohr")
      mycontext['state'] = 'RUNNING'
  elif mycontext['state'] == 'RUNNING': 
    print ("Program is currently running and messages will be hanled by running principles") 
#    msgheader = receiveMessage(sockobj)

    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith( 'GET' ):
      sendHTTPOK(sockobj)
    elif msgheader.startswith( 'POST' ):
      if (getmyip()!=mycontext['leader']):
        # Vessel is not leader, forwards the post request to the leader.
        msg = "UPT" + "<p>" + msgheader.split('comment=')[-1] + "</p>"
        sendMessage(mycontext['leader'], mycontext['port'], msg)

        #s = openconn(mycontext['leader'], mycontext['port']) 
        #s.send("UPT" + "<p>" + msgheader.split('comment=')[-1] + "</p>")
        #s.close
      else:
        # Vessel is leader, updates the input table with lock protected method below
        addMessageToInputTable("<p>" + msgheader.split('comment=')[-1] + "</p>")      
  
      sendHTTPOK(sockobj)

  	
    # Message sent from POST to update the mycontext['htmlinputtable']
    # (is not sent to local node)
    elif msgheader.startswith( 'UPT' ):
      print ("UPT-meddelande med innehÃ¥ll\n" + msgheader + "\n")
      print ("Current version: " + str(mycontext['version']) + "\nMessage version: " + msgheader[3:].split(":")[-1])

      if (getmyip()==mycontext['leader']):
        # Leader, modify mycontext board
        addMessageToInputTable(msgheader[3:])
      else:
        # Checks if newer version than current, then replace local board view        
        upDateLocalBoard(msgheader)

    stopcomm(thiscommhandle)

	
if callfunc == 'initialize':
  mycontext['state'] = 'ELECTION'
  mycontext['vessels'] = [] # Dictionary for all vessels (not scalable solution)
  mycontext['htmlinputtable'] = "" # The blackboard
  mycontext['socketLock'] = getlock()
  mycontext['inputTableLock'] = getlock() # Used by leader
  mycontext['upDateLocalBoardLock'] = getlock() # Used by non-leaders
  mycontext['version'] = 1
  mycontext['maxVersion'] = 1
  mycontext['savedMessages'] = {} 


  if len(callargs) > 2:
    raise Exception("Too many call arguments")

  # Running remotely (assuming that we pass input argument only remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  elif len(callargs) == 2:
    port = int(callargs[0])
    mycontext['port'] = port

    ip = getmyip()
    ipfile = open(callargs[1],'r')
    for line in ipfile:
      mycontext['vessels'].append(line.split()[0])

  # Running locally:
  # whenever we get a connection on 127.0.0.1:12345 we'll call board
  else:
    port = 12345
    ip = '127.0.0.1'
  

  index = mycontext['vessels'].index(getmyip()) + 1
  length = len(mycontext['vessels'])
  mycontext['nextvessel'] = mycontext['vessels'][index % length]

  mycontext['electnum'] = int(randomfloat()*1000)


  listencommhandle = waitforconn(ip,port,board)
 # sleep(2)
  startLeaderElection()

