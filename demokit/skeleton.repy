# Used when a new message is recieved via a POST request; will insert it at the end of te local board with the appripriate logical clock value and writeToQuorum it to the other vessels
def addMessageToInputTable(ip, msg):
  mycontext['inputTableLock'].acquire()

  for ip in mycontext['W']:
# Send to first vessel in Quorum
    mycontext['remoteLock'].acquire()
    sendMessage(ip, mycontext['port'], 'LOCK')

  readQuorum()
  mycontext['inputTableLock'].release()
  print 'Write to quorum'
  writeToQuorum(msg)


def lockLocalHost(ip):
  mycontext['lockLocalHost'].acquire()
  sendMessage(ip, mycontext['port'], 'REMOTE')

#  mycontext['boardList'].append(((mycontext['seqNumber'],ip), msg + str(mycontext['seqNumber'])))    
#  bmsg = getmyip() + ":" + str(mycontext['seqNumber']) + ":" + msg + str(mycontext['seqNumber']) 
#  mycontext['seqNumber'] += 1


# Updating local board after recieving a UPT-message from another vessel, with seqNumber handling
def upDateLocalBoard(msgheader):
#  seqNumber = int(msgheader[3:].split(":")[1])
#  ip = msgheader[3:].split(":")[0]
#  msg = msgheader[3:].split(":")[2]
  print 'upDATE'
  #mycontext['inputTableLock'].acquire()
  mycontext['boardList'].append(msgheader)
  mycontext['seqNumber'] += 1
#  if seqNumber >= mycontext['seqNumber']:
#    mycontext['boardList'].append(((seqNumber,ip), msg ))
#    mycontext['seqNumber'] = seqNumber + 1

#  else:
    # Iterates over the board. Checks if the seqNumber is the same as the list items.
    # If it is, it will compare their IPs and insert it on the right position.
    # If it reaches a list item that has a bigger seqNumber it will insert on that position.
 #   id = 0
 #   while  len(mycontext['boardList']) > id and int(mycontext['boardList'][id][0][0]) <= seqNumber:
 #     tup = mycontext['boardList'][id]
 #     listItemSeqNumber = int(tup[0][0])

#      if listItemSeqNumber == int(seqNumber):
#        listItemIP = tup[0][1]

#        if listItemIP > ip:
 #         mycontext['boardList'].insert(id, ((seqNumber,ip),msg))
  #        mycontext['inputTableLock'].release()
   #       return
   #   id += 1
  #  mycontext['boardList'].insert(id, ((seqNumber,ip),msg))

    

 # mycontext['inputTableLock'].release()

# Sends a HHTP OK when receiving a webbrowser request
def sendHTTPOK(sockobj):
  # The HTML code is divided in two parts, htmlpartone and hmtlparttwo.
  # mycontext['htmlinputtable'] is then inserted between them

  htmlpartone = """<html><head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Blackboard GroupName</title>
    </head>
    <body>
    <h2> Board Content</h2>"""

  htmlparttwo = """
    <br>
    <h3>Submit to board<h3>
    <textarea rows="4" cols="50" name="comment" form="usrform"></textarea>
    <form action="" id="usrform" method="post">
    <input type="submit">
    </form>
    </body></html>"""

  board = ""
  for content in mycontext['boardList']:
    board += "<p>" + content + "</p>" 


  htmlresponse = htmlpartone + board + htmlparttwo
  sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
  "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))


def receiveMessage(sockobj):
  msgheader = ""
  timeout = 2
  nextpart = ""
  first = 1

  while first or len(nextpart) == 1024:
    try:
      nextpart = sockobj.recv(1024)
      msgheader = msgheader + nextpart
      if first:
        first = 0
    except Exception, e:
      print 'Exception caught: ', str(e), ', in receiveMessage(). Will return ' + msgheader
      nextpart = ""
  return msgheader


def sendMessage(ip, port, msg, numberOfTries=1000, tryNumber=0):
  try:
    mycontext['socketLock'].acquire()
    s = openconn(ip, port)
    s.send(msg)
    s.close()
    mycontext['socketLock'].release()
  except Exception, e:
    print 'Exception caught: ', str(e)
    if(tryNumber < numberOfTries):

      mycontext['socketLock'].release()
      sendMessage(ip, port, msg, numberOfTries, tryNumber+1)
    else:
      raise e

def readQuorum():
  # This is for performance and ME-protection for the inputtable
  if mycontext['readLock'].acquire(0):
    msg = 'CHECK'
    for vessel in mycontext['R']:
      sendMessage(vessel, mycontext['port'], msg)
    # Lock and wait for the messages to arrive
    mycontext['waitForAnswers'].acquire()

    maxSeqNumber = mycontext['seqNumber']
    ip = getmyip()
    print maxSeqNumber
    for tup in mycontext['readSeqAnswers']:
      tempSeqNumber = int(tup[0])
      tempIP = tup[1]

      if tempSeqNumber > maxSeqNumber:
        maxSeqNumber = tempSeqNumber
        ip = tempIP
        print 'changed'


    print maxSeqNumber
    if ip != getmyip():
      # Send this message to other vessel... Not use copyBoard() local
      print 'Asking ' + ip +' for newest version.'
      sendMessage(ip, mycontext['port'], 'COPY:' + str(mycontext['seqNumber']))
      mycontext['copying'].acquire()
      mycontext['seqNumber'] = maxSeqNumber

#      copyBoard(ip, mycontext['seqNumber'])
    # do things

    # unlock
    mycontext['readSeqAnswers'] = []
    mycontext['readLock'].release()

def copyBoard(ip, msgheader):
  seqNumber = int(msgheader.split(':')[-1])
  for content in mycontext['boardList'][seqNumber:]:
    msg = "PASTE:" + content + ':MORE'
    sendMessage(ip, mycontext['port'], msg)
  msg = 'PASTE: :FINISHED'
  sendMessage(ip, mycontext['port'], msg)

def sendSeqNr(ip):
  msg = 'SEQ:' + str(mycontext['seqNumber']) + ':' + getmyip()
  sendMessage(ip, mycontext['port'], msg)

def receiveSeqNumberLogic(msgheader):
  seqNumber = msgheader.split(':')[1]
  ip = msgheader.split(':')[2]
  mycontext['readSeqAnswers'].append((seqNumber,ip))

  if len(mycontext['readSeqAnswers']) == len(mycontext['R']):
    mycontext['waitForAnswers'].release()


def writeToQuorum(newInput):
  for ipn in mycontext['W']:
    msg ="UPT:" + newInput
    sendMessage(ipn, mycontext['port'], msg)

# Handles incoming communication
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  msgheader = receiveMessage(sockobj)

  if mycontext['state'] == 'RUNNING': 
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith ('GET' ):
      readQuorum()
      sendHTTPOK(sockobj)
    elif msgheader.startswith( 'POST' ):
      addMessageToInputTable(getmyip(), msgheader.split('comment=')[-1])
      sendHTTPOK(sockobj)

  	
    # UPT-messages handles the updating of mycontext['boardList']
    elif msgheader.startswith( 'UPT' ):
      upDateLocalBoard(msgheader[4:])
      mycontext['lockLocalHost'].release()

    elif msgheader.startswith( 'CHECK' ):
      sendSeqNr(ip)
    elif msgheader.startswith( 'SEQ' ):
      receiveSeqNumberLogic(msgheader)
    elif msgheader.startswith( 'REMOTE' ):
      mycontext['remoteLock'].release()
    elif msgheader.startswith( 'LOCK' ):
      lockLocalHost(ip)
    elif msgheader.startswith( 'COPY' ):
      copyBoard(ip, msgheader)
    elif msgheader.startswith( 'PASTE' ):
      print ' PASTE'
      if msgheader.endswith( 'MORE' ):
        print ' MORE'
        upDateLocalBoard(msgheader.split(':')[1])
      else:
        print 'FINISHED'
        mycontext['copying'].release()


    stopcomm(thiscommhandle)

	
if callfunc == 'initialize':
  mycontext['state'] = 'RUNNING'
  mycontext['vessels'] = [] # List of all vessels (not scalable solution)
  mycontext['htmlinputtable'] = "" # The blackboard
  mycontext['socketLock'] = getlock()
  mycontext['inputTableLock'] = getlock() # Protects the input table
  mycontext['waitForAnswers'] =getlock()
  mycontext['readLock'] = getlock()
  mycontext['waitForAnswers'].acquire()
  mycontext['remoteLock'] = getlock()
  mycontext['lockLocalHost'] = getlock()
  mycontext['copying'] = getlock()
  mycontext['copying'].acquire()
  mycontext['seqNumber'] = 0
  mycontext['maxVersion'] = 1
  mycontext['savedMessages'] = {} 

  mycontext['R'] = []
  mycontext['W'] = []
  mycontext['readSeqAnswers'] = []


  mycontext['boardList'] = []


  if len(callargs) > 2:
    raise Exception("Too many call arguments")

  # Running remotely (assuming that we pass input argument only remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  elif len(callargs) == 2:
    port = int(callargs[0])
    mycontext['port'] = port

    ip = getmyip()
    ipfile = open(callargs[1],'r')

    otherVessels = []
    for line in ipfile:
      if(line != ip):
        otherVessels.append(line.split()[0])
      mycontext['vessels'].append(line.split()[0])

    n = len(mycontext['vessels'])

    mycontext['R'] = otherVessels[:(n/2-1+n%2)] # This is the read quorum, but the local vessel is missing. Because we don't want to send messages to it.
#    mycontext['R'].append(ip)
    print mycontext['R']
    mycontext['W'] = mycontext['vessels'][:(n/2+1+n%2)]
   # mycontext['W'].append(ip)
    print mycontext['W']

  # Running locally:
  # whenever we get a connection on 127.0.0.1:12345 we'll call board
  else:
    port = 12345
    ip = '127.0.0.1'
  
  listencommhandle = waitforconn(ip,port,board)
