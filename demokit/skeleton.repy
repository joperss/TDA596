def sendMessage(ip, port, msg, numberOfTries=5, tryNumber=0):
  try:
    s = openconn(ip, port)
    print "Trying to send message"
    s.send(msg)
    print "Message sent"
    s.close
  except Exception, e:
    print 'Exception caught: ', str(e)
    print "Neighbour not ready, will try again in 1 s"
    if(tryNumber < numberOfTries):
      sleep(1)
      sendMessage(ip, port, msg, numberOfTries, tryNumber+1)
    else:
      raise e
def leaderBroadcast():
  for ipn in mycontext['vessels']:
    if(ipn != mycontext['leader']):
      msg ="UPT" + mycontext['htmlinputtable']
      sendMessage(ipn, mycontext['port'], msg)


# Sets leader to '' and sends the vessel's first message in the leader election
def startLeaderElection():
  mycontext['leader'] = ''
  print "Opening connection to ip " + mycontext['nextvessel'] + " on port " + str(mycontext['port'])
  
  msg = "ELECT:" + getmyip() + ":" + str(mycontext['electnum'])
  sendMessage(mycontext['nextvessel'], mycontext['port'], msg)  

def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  print "Request received"
  if mycontext['state'] == 'ELECTION':
    msgheader = sockobj.recv(1024)
    if msgheader.startswith('ELECT'):
      if msgheader.split(':')[1] == getmyip():
        msgheader = msgheader[6:]
        vesselList = msgheader.split(':')
        index = 0
        max = 0
        leaderIndex = 0
        print vesselList
        for n in vesselList:
          if index % 2 != 0:
            # BOGUS: bad if n == max
            if n > max:
              max = n
              leaderIndex = index-1
          index += 1

        mycontext['leader'] =  vesselList[leaderIndex]
        mycontext['htmlinputtable'] = "<p>" + mycontext['leader'] + "</p>"
        # Send CONF
        print "Sending conf message, starts running phase"
        msg = "CONFIRM:" + mycontext['leader']
        sendMessage(mycontext['nextvessel'], mycontext['port'], msg)

        mycontext['state'] = 'RUNNING'

      else:
        # Add values to message
        print "Sends to next vessel " + mycontext['nextvessel'] + " at port " + str(mycontext['port'])
        msg = msgheader + ":" + getmyip() + ":" +  str(mycontext['electnum'])
        sendMessage(mycontext['nextvessel'], mycontext['port'], msg)

    elif msgheader.startswith('CONFIRM'):
      mycontext['leader'] = msgheader.split(':')[-1]
      mycontext['htmlinputtable'] = "<p>" + mycontext['leader'] + "</p>"


      msg = msgheader
      sendMessage(mycontext['nextvessel'], mycontext['port'], msg)
      
      mycontext['state'] = 'RUNNING'
  elif mycontext['state'] == 'RUNNING': 

    # Sometimes the socket closes before sockobj.recv() finishes, but after msgheader is fully retrieved.
    # As far as we can tell, this only happens on some systems.
    # This try-except handles thoses cases
    msgheader = ''
    try:
      msgheader = sockobj.recv(1024) # Receive message,
    except Exception,e:
      if msgheader:
        print 'Exception caught: ', str(e)
        print 'Message received but socket was closed prematurely'
      else:
        print 'Exception caught: ', str(e)
        print 'Nothing received'
        stopcomm(thiscommhandle)
        return

    
    # The HTML code is divided in two parts, htmlpartone and hmtlparttwo.
    # mycontext['htmlinputtable'] is then inserted between them
    htmlpartone = """<html><head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Blackboard GroupName</title>
    </head>
    <body>
    <h2> Board Content</h2>"""

    htmlparttwo = """
    <br>
    <h3>Submit to board<h3>
    <textarea rows="4" cols="50" name="comment" form="usrform"></textarea>
    <form action="" id="usrform" method="post">
    <input type="submit">
    </form>
    </body></html>"""

    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith( 'GET' ):
      htmlresponse = htmlpartone + mycontext['htmlinputtable'] + htmlparttwo
      sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
      "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))   
    elif msgheader.startswith( 'POST' ):
      # If POST message does not contain a comment= section, try to fetch more
      if not 'comment=' in msgheader:
        timeout = 2
        nextpart = ''
        begin = getruntime()
        while not 'comment=' in msgheader:
          if getruntime() - begin > timeout:
            print 'Failed to retrieve messages, timeout'
            stopcomm(thiscommhandle)
            return
          try:
            nextpart = sockobj.recv(1024)
          except Exception,e:
            # Same as above, socket closed after message was received, but beofre recv finished
            if nextpart:
              print 'Exception caught: ', str(e)
              print 'Message received but socket was closed prematurely'
            else:
              print 'Exception caught: ', str(e)
              print 'Comment not received'
              stopcomm(thiscommhandle)
              return

          if nextpart:
            msgheader = msgheader + nextpart
            begin = getruntime()
          else:
            # Not sure how to handle this, could probably use pass too
            sleep(0.1)




      # Update all vessels blackboard model. (Still need to hit refresh on remote hosts)
  #    for ipn in mycontext['vessels']:
        #  if(ipn != getmyip()):
      if (getmyip()!=mycontext['leader']):
        msg = "UPT" + "<p>" + msgheader.split('comment=')[-1] + "</p>"
        sendMessage(mycontext['leader'], mycontext['port'], msg)

        #s = openconn(mycontext['leader'], mycontext['port']) 
        #s.send("UPT" + "<p>" + msgheader.split('comment=')[-1] + "</p>")
        #s.close
      else:
        print("The leader updated self and added: " + msgheader.split('comment=')[-1] + "\n")
        mycontext['htmlinputtable'] = mycontext['htmlinputtable'] + "<p>" + msgheader.split('comment=')[-1] + "</p>"
        leaderBroadcast()
      
      htmlresponse = htmlpartone + mycontext['htmlinputtable'] + htmlparttwo
      sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
      "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))

  	
    # Message sent from POST to update the mycontext['htmlinputtable']
    # (is not sent to local node)
    elif msgheader.startswith( 'UPT' ):
      if (getmyip()==mycontext['leader']):
        mycontext['htmlinputtable'] = mycontext['htmlinputtable'] + msgheader[3:]
        print("New value in leader:" + mycontext['htmlinputtable'])
        leaderBroadcast()
      else:
        mycontext['htmlinputtable'] = msgheader[3:]
        print("New value in node:" + mycontext['htmlinputtable'])

    stopcomm(thiscommhandle)

	
if callfunc == 'initialize':
  mycontext['state'] = 'ELECTION'
  mycontext['vessels'] = [] # Dictionary for all vessels (not scalable solution)
  mycontext['htmlinputtable'] = "" # The blackboard

  if len(callargs) > 2:
    raise Exception("Too many call arguments")

  # Running remotely (assuming that we pass input argument only remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  elif len(callargs) == 2:
    port = int(callargs[0])
    mycontext['port'] = port

    ip = getmyip()
    ipfile = open(callargs[1],'r')
    for line in ipfile:
      mycontext['vessels'].append(line.split()[0])

  # Running locally:
  # whenever we get a connection on 127.0.0.1:12345 we'll call board
  else:
    port = 12345
    ip = '127.0.0.1'
  

  index = mycontext['vessels'].index(getmyip()) + 1
  length = len(mycontext['vessels'])
  mycontext['nextvessel'] = mycontext['vessels'][index % length]

  mycontext['electnum'] = int(randomfloat()*1000)
  listencommhandle = waitforconn(ip,port,board)
 # sleep(2)
  startLeaderElection()

