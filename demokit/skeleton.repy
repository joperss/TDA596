# Used by the leader to add messages to it's content table
def addMessageToInputTable(ip, msg):
  mycontext['inputTableLock'].acquire()

  mycontext['boardList'].append(((mycontext['seqNummer'],ip), "<p>" + msg + str(mycontext['seqNummer']) + "</p>"))    
  bmsg = getmyip() + ":" + str(mycontext['seqNummer']) + ":<p>" + msg + str(mycontext['seqNummer']) +  "</p>"
  mycontext['seqNummer'] += 1

  mycontext['inputTableLock'].release()
  broadcast("<p>" + bmsg + "</p>")

# Updating local board after recieving a UPT-message, with seqNummer handling
def upDateLocalBoard(msgheader):
  seqNummer = int(msgheader[3:].split(":")[1])
  ip = msgheader[3:].split(":")[0]
  msg = msgheader[3:].split(":")[2]
 # print "New input" + msg
  mycontext['inputTableLock'].acquire()

  if seqNummer >= mycontext['seqNummer']:
    print "'D' appended." + "seqNummer: " + str(seqNummer) + " ip: " + ip

    mycontext['boardList'].append(((seqNummer,ip), msg ))
    mycontext['seqNummer'] = seqNummer + 1
#    print "Appended msg to boardlist"
  else:
    id = 0
   # print "lenght of boardList"
   # print len(mycontext['boardList'])
   # print "seqNummer: " + str(seqNummer) + " ip: " + ip
    while  len(mycontext['boardList']) > id and int(mycontext['boardList'][id][0][0]) <= seqNummer:
      tup = mycontext['boardList'][id]
 #     print tup
 #     print "tup: "+ str(tup[0][0]) + " seqNummer: " + str(seqNummer)
       
      listItemSeqNumber = int(tup[0][0])

      if listItemSeqNumber == int(seqNummer):
        print tup[0][1] + " i compared with " + ip
        print str(listItemSeqNumber) + " was compared with " + str(seqNummer)
        listItemIP = tup[0][1]

        if listItemIP > ip:
          print "'A' inserted at " + str(id) + ". seqNummer: " + str(seqNummer) + " ip: " + ip
          mycontext['boardList'].insert(id, ((seqNummer,ip),msg))
          mycontext['inputTableLock'].release()
          return
      elif listItemSeqNumber > int(seqNummer) :
          # Should be unreachable
        print "'C'Inserted at " + str(id) + ". seqNummer: " + str(seqNummer) + " ip: " + ip
        mycontext['boardList'].insert(id, ((seqNummer,ip),msg))


      id += 1
    
    print "'B'Inserted at " + str(id) + ". seqNummer: " + str(seqNummer) + " ip: " + ip
    mycontext['boardList'].insert(id, ((seqNummer,ip),msg))

#    mycontext['boardList'].append(((seqNummer,ip),msg))

    

  mycontext['inputTableLock'].release()

# Sends a HHTP OK when receiving a webbrowser request
def sendHTTPOK(sockobj):
  # The HTML code is divided in two parts, htmlpartone and hmtlparttwo.
  # mycontext['htmlinputtable'] is then inserted between them

  htmlpartone = """<html><head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <title>Blackboard GroupName</title>
    </head>
    <body>
    <h2> Board Content</h2>"""

  htmlparttwo = """
    <br>
    <h3>Submit to board<h3>
    <textarea rows="4" cols="50" name="comment" form="usrform"></textarea>
    <form action="" id="usrform" method="post">
    <input type="submit">
    </form>
    </body></html>"""

  board = ""
  for tup in mycontext['boardList']:
    board += tup[1]


  htmlresponse = htmlpartone + board + htmlparttwo
  sockobj.send("HTTP/1.1 200 OK\r\nContent-type: text/html\r\n" + \
  "Content-length: %i\r\n\r\n%s" % (len(htmlresponse), htmlresponse))

 # print "Board updated " + str(getruntime())


def receiveMessage(sockobj):
  msgheader = ""
  timeout = 2
  nextpart = ""
  first = 1

  while first or len(nextpart) == 1024:
    try:
      nextpart = sockobj.recv(1024)
      msgheader = msgheader + nextpart
      if first:
        first = 0
    except Exception, e:
      print 'Exception caught: ', str(e), ', in receiveMessage(). Will return ' + msgheader
      nextpart = ""
  return msgheader


def sendMessage(ip, port, msg, numberOfTries=1000, tryNumber=0):
  try:
    mycontext['socketLock'].acquire()
    s = openconn(ip, port)
    s.send(msg)
    s.close()
    mycontext['socketLock'].release()
  except Exception, e:
    print 'Exception caught: ', str(e)
    if(tryNumber < numberOfTries):

      mycontext['socketLock'].release()
      sendMessage(ip, port, msg, numberOfTries, tryNumber+1)
    else:
      raise e

def broadcast(newInput):
  for ipn in mycontext['vessels']:
    if(ipn != getmyip()):
      msg ="UPT" + newInput + ":" + str(mycontext['seqNummer'])
      sendMessage(ipn, mycontext['port'], msg)

# Handles incoming communication
def board(ip, port, sockobj, thiscommhandle, listencommhandle):
  msgheader = receiveMessage(sockobj)

  if mycontext['state'] == 'RUNNING': 
    # React depending on message type: HTTP GET or POST, or some other type of communication.
    if msgheader.startswith ('GET' ):
      sendHTTPOK(sockobj)
    elif msgheader.startswith( 'POST' ):
      # Vessel is not leader, forwards the post request to the leader.
  #    print "A post at " + str(getruntime())
      addMessageToInputTable(getmyip(), msgheader.split('comment=')[-1])
  
      sendHTTPOK(sockobj)

  	
    # UPT-messages handles the updating of mycontext['htmlinputtable']
    elif msgheader.startswith( 'UPT' ):
 #     print "Updating the board at " + str(getruntime())
#      if (getmyip()==mycontext['leader']):
        # Leader, modify mycontext board
 #     addMessageToInputTable(msgheader[3:])
 #     else:
        # Checks if newer seqNummer than current, then replace local board view 
      upDateLocalBoard(msgheader[3:])

    stopcomm(thiscommhandle)

	
if callfunc == 'initialize':
  mycontext['state'] = 'RUNNING'
  mycontext['vessels'] = [] # Dictionary for all vessels (not scalable solution)
  mycontext['htmlinputtable'] = "" # The blackboard
  mycontext['socketLock'] = getlock()
  mycontext['inputTableLock'] = getlock() # Protects the input table
  mycontext['seqNummer'] = 1
  mycontext['maxVersion'] = 1
  mycontext['savedMessages'] = {} 

  mycontext['boardList'] = []


  if len(callargs) > 2:
    raise Exception("Too many call arguments")

  # Running remotely (assuming that we pass input argument only remotely):
  # whenever this vessel gets a connection on its IPaddress:Clearinghouseport it'll call function board
  elif len(callargs) == 2:
    port = int(callargs[0])
    mycontext['port'] = port

    ip = getmyip()
    ipfile = open(callargs[1],'r')
    for line in ipfile:
      mycontext['vessels'].append(line.split()[0])

  # Running locally:
  # whenever we get a connection on 127.0.0.1:12345 we'll call board
  else:
    port = 12345
    ip = '127.0.0.1'
  

  index = mycontext['vessels'].index(getmyip()) + 1
  length = len(mycontext['vessels'])
  mycontext['nextvessel'] = mycontext['vessels'][index % length]

  mycontext['electnum'] = int(randomfloat()*1000)


  listencommhandle = waitforconn(ip,port,board)
